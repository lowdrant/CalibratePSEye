#!/usr/bin/env python3
"""
This software is copyrighted material (C) Marion Anderson 2020

The library is provided under the Apache 2.0 License,
as found at https://www.apache.org/licenses/LICENSE-2.0

    OVERVIEW:

    Script to explore the effects of truncating sigfigs on camera calibration
    precision. This process use `cameraMatrix` and `distCoeffs`. The outcome
    will inform parameter storage in `CalibratePSEye`. To minimize wasted
    storage, don't store unnecessary sigfigs in the calibration files. Uses
    `logging` for output.

    PRECISION BENCHMARK:

    Using a PSEye camera with resolution 320x240px at a distance of 1.8m from
    the robot, the BIRDS Lab's retroreflective markers are 4px in diameter.
    This gives an upper bound on precision of 1/4px on centroid measurement.
                                              ^^^^^

    LIMITATIONS:

    Setting the pixel grid resolution too high (`dp` too low) can make this
    program very memory hungry. If you get any sort of 'Killed' message, your
    computer probably ran out of memory when calling `projectPoints`.

    OpenCV's distortion inverse approximation is limited. A call of
    `projectPoints` using full-precision parameters to invert `undistortPoints`
    gave an error of 0.028415445621407px where 0.0000000000000px would be
    expected from a perfect inverse.

    Limitations last updated on 2020-07-08

    USAGE

        usage: precision.py [-h] [-nd] [-jr] [--target TARGET] [--dp DP] [--dist Z]
                            [--width W] [--height H] [--debug]
                            [calibdir]

        Find minimum sigfigs/decimals to achieve a target pixel resolution

        positional arguments:
          calibdir          Directory of calibration images. See CalibratePSEye.py for
                            details. (default: tests/calibs_00000000-000000)

        optional arguments:
          -h, --help        show this help message and exit
          -nd, --nodistort  only use camera matrix in analysis
          -jr, --justround  use decimal rounding instead of sigfig rounding
          --target TARGET   target resolution [px] (default: 0.25)
          --dp DP           resolution [px] of image plane grid (default: 0.5)
          --dist Z          distance [mm] from image plane to object plane (default:
                            1.8e3)
          --width W         width [px] of image plane (default: 320)
          --height H        height [px] of image plane (default: 240)
          --debug           set loglevel to debug

    TECHNICAL DETAILS:

    This script relies heavily on OpenCV's `undistortPoints`, `projectPoints`,
    and camera calibration interfaces.

    https://docs.opencv.org/3.2.0/d9/d0c/group__calib3d.html
    https://docs.opencv.org/3.2.0/d9/d0c/group__calib3d.html#ga1019495a2c8d1743ed5cc23fa0daff8c
    https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#ga887960ea1bde84784e7f1710a922b93c

    ALGORITHM:

        1. Generate full-precision calibration matrices from calibration images
           - text files might have truncation, so don't load from CSV/YAML/etc

        2. Remove autogenerated calibration directory from `load_calib_imgs`

        3. Generate a grid of image-plane pixel points: (u,v)

        4. Using full precision, project (u,v) to the object-plane (X,Y) at fixed Z

        5. Iteratively:
            a. truncate the least-signficant sigfig or decimal
            b. backproject (X,Y) to image plane, giving new coords (u',v')
            c. measure worst normed error between (u,v) and (u',v')
               - points correspond by index; err = 2norm( (u,v)-(u',v') )
                 - this is your typical vector norm from Physics 1
            d. break when worst normed error exceeds precision
"""
import logging
from argparse import ArgumentParser
from os.path import realpath

from cv2 import projectPoints, undistortPoints
from numpy import (arange, around, array2string, ceil, concatenate, log10,
                   meshgrid, newaxis, sign, zeros)
from numpy.linalg import norm

from CalibratePSEye import CalibratePSEye

logging.getLogger('pseye.CalibratePSEye').setLevel(logging.WARNING)  # suppress


def arrsf(arr, sf, justround=False):
        """
        Round to decimal place that corresonds to sf significant figures for all
        entries in an array.

        INPUTS
            arr -- ndarray -- array to reduce sigfigs (not round!)
            sf  -- int     -- how many sigfigs to cut
            (optional)
            justround -- bool -- flag to round by decimal; False

        OUTPUTS
            arr2 -- ndarray -- array with reduced sigfigs

        ALGORITHM
            1. Flatten array to find 0-valued entries
            2. Find the highest order sig fig of each entry
            3. Scale each entry to be of the form: 0.X
            4. Round: now decimal places = sigfigs
            5. Rescale entries back to their original order of magnitude
            6. Re-insert 0-valued entries and reshape to match arr.shape
        """
        if int(sf) != sf or sf < 1:
            raise ValueError('\'sf\' must be positive int')

        if justround:
            return around(arr, decimals=sf)

        # Set sigfigs
        flat = arr.flatten()                                    # need sign
        aflat = abs(flat)                                       # avoid log10(-X)
        ndx = aflat != 0
        b10exp = log10(aflat[ndx]).astype('int') + 1            # +1 to get 0.X
        aflat2 = around(aflat[ndx]*10.0**-b10exp, decimals=sf)  # set sigfigs
        aflat2 *= 10.0**b10exp                                  # rescale

        # Reshape/reformat
        arr2 = zeros(flat.shape, dtype=flat.dtype)
        arr2[ndx] = aflat2 * sign(flat[ndx])                    # reset sign
        arr2[~ndx] = flat[~ndx]                                 # reinsert 0
        return arr2.reshape(arr.shape)


# =============================================================================
# CLI Setup
# =============================================================================

# test case calibration path
rootdir = realpath(__file__ + '/../..')  # read from test calib imgs
pdir = rootdir + '/tests/calibs_00000000-000000'

parser = ArgumentParser(
    description='Find minimum sigfigs/decimals to achieve a target pixel resolution'
)
parser.add_argument(
    dest='calibdir', default=pdir, nargs='?',
    help=('Directory of calibration images. See CalibratePSEye.py for details.'
          + ' (default: tests/calibs_00000000-000000)')
)
parser.add_argument(
    '-nd', '--nodistort', action='store_false',
    help='only use camera matrix in analysis'
)
parser.add_argument(
    '-jr', '--justround', action='store_true',
    help='use decimal rounding instead of sigfig rounding'
)
parser.add_argument(
    '--target', type=float, default=0.25,
    help='target resolution [px] (default: 0.25)'
)
parser.add_argument(
    '--dp', default=0.5, type=float,
    help='resolution [px] of image plane grid (default: 0.5)'
)
parser.add_argument(
    '--dist', dest='Z', default=1.8e3, type=float,
    help='distance [mm] from image plane to object plane (default: 1.8e3)'
)
parser.add_argument(
    '--width', dest='W', default=320,
    help='width [px] of image plane (default: 320)'
)
parser.add_argument(
    '--height', dest='H', default=240,
    help='height [px] of image plane (default: 240)'
)
parser.add_argument(
    '--debug', action='store_true', help='set loglevel to debug'
)
args = parser.parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG, format='%(levelname)s:%(message)s')
else:
    logging.basicConfig(level=logging.INFO, format='%(levelname)s:%(message)s')

target = args.target
distort = args.nodistort
justround = args.justround
dp = args.dp
Z = args.Z
W = args.W
H = args.H

logging.debug(args)

# =============================================================================
# Compute Calibrations from Images
#   don't load matrices from file to avoid sigfig truncation
# =============================================================================

calibs = CalibratePSEye()
calibs.init_chessboard(pdir+'/processing_params.csv', pdir+'/objp.csv')
# ensure autogenerated directory cleanup
#   `finally` gets executed before `except`
#    https://docs.python.org/3/reference/compound_stmts.html#finally
try:
    fni = rootdir + '/tests/raw'
    calibs.load_calib_imgs(fni)
    calibs.compute_calibrations()
    cmref = calibs.cameraMatrix.copy()
    dcref = None  # for OpenCV functions
    if distort:
        dcref = calibs.distCoeffs.copy()
except Exception as e:
    raise e
finally:
    calibs.removepath()
    del calibs

# =============================================================================
# Generate Grid
# =============================================================================

# Image Plane Grid (units:px)
#   2-channel coordinate vector (shape:Nx1x2) for `undistortPoints`
u = arange(0, W+dp, dp, dtype='float64')  # force max resolution
v = arange(0, H+dp, dp, dtype='float64')
gu, gv = meshgrid(u, v)
gU = gu.flatten()[...,newaxis,newaxis]
gV = gv.flatten()[...,newaxis,newaxis]
gUV = zeros((gU.shape[0],1,2))
concatenate((gU,gV), axis=2, out=gUV)
del gu, gv, gU, gV  # half-hearted attempt to free memory for projectPoints

# Object Plane Grid (units:mm)
#   gXYZ as Nx1x3 to get Nx1x2 out of `projectPoints`
gXYZ = zeros((gUV.shape[0],1,3))
gXY = undistortPoints(gUV, cmref, dcref)  # gives x=X/Z, yY/Z
gXYZ[...,:-1] = Z*gXY
gXYZ[...,-1] = Z
del gXY  # half-hearted attempt to free memory for projectPoints

# uncomment this block to convince yourself that distortion inversion is
# the primary contributer to error.
# test = zeros(gUV.shape)
# projectPoints(gXYZ, (0,0,0), (0,0,0), cmref, dcref, imagePoints=test)
# asdf = test - gUV
# asdf1 = norm(asdf, axis=0).max()
# print(asdf1)

logging.debug('max gridZ %0.2f' % gXYZ[-1,:].max())
logging.debug('min gridZ %0.2f' % gXYZ[-1,:].min())

# =============================================================================
# Iterative Rounding
# =============================================================================

# Get Sigfigs
dec = 15  # float64 -> 15 decimals
cmwhole = ceil(log10(abs(cmref).max()))  # whole part of number
dcwhole = 0                              # placeholder to reduce logic
if distort:
    dcwhole = ceil(log10(abs(dcref).max()))
whole = max((cmwhole, dcwhole))
sigfigs = int(dec + whole)               # more readable to int here
logging.debug('%d sigfigs' % sigfigs)

# Iterate
gUVnew = zeros(gUV.shape)  # prealloc saves RAM
dg = zeros(gUV.shape)
dc = None                  # placeholder to reduce logic
roundunits = 'sigfigs'     # better labelling for different rounding methods
if justround:
    roundunits = 'decimals'
for sf in range(sigfigs, 0, -1):

    # round
    cm = arrsf(cmref, sf, justround=justround)
    logging.debug('cameraMatrix\n%s' % array2string(cm))
    if distort:
        dc = arrsf(dcref, sf, justround=justround)
        logging.debug('distCoeffs\n%s' % array2string(dc))

    # map back to image plane
    projectPoints(gXYZ, (0,0,0), (0,0,0), cm, dc, imagePoints=gUVnew)

    # measure error error
    dg = gUV - gUVnew  # save separately for debugging
    err = norm(dg, axis=0).max()
    logging.info('Worst case error at %s %s: %.15fpx' % (str(sf).zfill(2), roundunits, err))
    if err > target:
        print('Error exceeded %.3fpx at %s %s' % (target, str(sf).zfill(2), roundunits))
        break
